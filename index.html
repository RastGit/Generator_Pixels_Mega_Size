<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>8GB BMP 2×2</title>
<style>
  body{background:#0f0f12;color:#e8e8ea;font-family:system-ui,sans-serif;margin:0;padding:16px}
  button{padding:10px 14px;font-size:15px;background:#1f1f26;color:#e8e8ea;border:1px solid #333;border-radius:8px;cursor:pointer}
  #log{white-space:pre-wrap;background:#121218;border:1px solid #222;padding:10px;border-radius:8px;margin-top:12px}
</style>
</head>
<body>
<h2>Generator BMP ~8GB (4 obrazy w kwadracie 2×2)</h2>
<button id="start">Generuj i zapisz</button>
<div id="log"></div>

<script>
const logEl = document.getElementById("log");
const log = t => { logEl.textContent += t + "\\n"; };

// Wymiary ćwiartki dobrane, by 4×RGB bez kompresji ≈ 8GB.
// Możesz zmienić, ale wtedy rozmiar się zmieni.
const QW = 32768; // szerokość ćwiartki
const QH = 21845; // wysokość ćwiartki
// Całość:
const W = QW * 2;
const H = QH * 2;

// BMP 24-bit: 3 bajty/piksel + padding do 4 bajtów na linię
function rowStride(width){
  const raw = width * 3;
  return raw + ((4 - (raw % 4)) % 4);
}

function writeLE(view, offset, value, bytes){
  for(let i=0;i<bytes;i++){
    view.setUint8(offset+i, value & 0xFF);
    value >>>= 8;
  }
}

async function saveHugeBMP(){
  if(!window.showSaveFilePicker){
    log("Twoja przeglądarka nie wspiera zapisu strumieniowego. Użyj Chrome/Edge.");
    return;
  }

  const fileHandle = await window.showSaveFilePicker({
    suggestedName: "mega_8gb.bmp",
    types: [{ description: "BMP", accept: {"image/bmp":[".bmp"]} }]
  });
  const writable = await fileHandle.createWritable();

  const stride = rowStride(W);
  const pixelDataSize = stride * H;
  const fileSize = 14 + 40 + pixelDataSize; // nagłówek BMP + DIB + dane

  // --- Nagłówek BMP (14B) + DIB (40B) ---
  const header = new ArrayBuffer(54);
  const view = new DataView(header);
  // 'BM'
  view.setUint8(0, 0x42); view.setUint8(1, 0x4D);
  writeLE(view, 2, fileSize, 4);
  writeLE(view, 10, 54, 4); // offset danych
  writeLE(view, 14, 40, 4); // rozmiar DIB
  writeLE(view, 18, W, 4);
  writeLE(view, 22, H, 4);
  writeLE(view, 26, 1, 2);  // planes
  writeLE(view, 28, 24, 2); // bpp
  writeLE(view, 34, pixelDataSize, 4);

  await writable.write(header);

  // --- Dane pikseli: zapis od dołu (BMP tak chce) ---
  const pad = new Uint8Array(stride - W*3);
  let rowsDone = 0;
  const totalRows = H;

  function randByte(){ return Math.floor(Math.random()*256); }

  for(let y=0; y<H; y++){
    // Tworzymy linię z 4 różnych ćwiartek w układzie 2×2
    const row = new Uint8Array(W*3);
    for(let x=0; x<W; x++){
      // Która ćwiartka?
      const left = x < QW;
      const top = y >= QH; // pamiętaj: zapis od dołu, więc górna połowa to y>=QH
      // Każda ćwiartka ma własny „charakter” losowania, żeby były różne
      let r,g,b;
      if(left && !top){ r=randByte(); g=randByte(); b=randByte(); }             // dół-lewo
      else if(!left && !top){ r=randByte(); g=randByte(); b=(randByte()^128); } // dół-prawo
      else if(left && top){ r=(randByte()^64); g=randByte(); b=randByte(); }    // góra-lewo
      else { r=randByte(); g=(randByte()^32); b=randByte(); }                   // góra-prawo

      const i = x*3;
      row[i] = b; row[i+1] = g; row[i+2] = r; // BMP: BGR
    }
    await writable.write(row);
    if(pad.length) await writable.write(pad);

    rowsDone++;
    if(rowsDone % 200 === 0){
      const pct = ((rowsDone/totalRows)*100).toFixed(2);
      log(`Postęp: ${rowsDone}/${totalRows} wierszy (${pct}%)`);
      await new Promise(r=>setTimeout(r,0));
    }
  }

  await writable.close();
  log("Zapis zakończony. Jeśli dysk przeżył, masz ~8GB BMP.");
}

document.getElementById("start").onclick = saveHugeBMP;
</script>
</body>
</html>
